#!/usr/bin/env python
#
# romipi_fiducials.py
#
# The purpose of this program is to recognize aruco fiducials
# for localization
# 
# Peter F. Klemperer
# June 20, 2019
#
# Design Plan
# 1. Basic Publisher / Subscriber
# 2. Subscribe to images from pi
# 3. Publish images for debug
# 4. Open the Aruco Library
# 5. Apply Aruco and publish the fiducials 
#
# Look at the C++ based example in aruco_detect.py
# from the aruco_detect library located at:
# 

import rospy

# message types
from std_msgs.msg import String
from sensor_msgs.msg import CompressedImage
from geometry_msgs.msg import PoseStamped
from romipi_msgs.msg import RomiPose

# opencv2 realted
import cv2
import numpy as np
import math
import cv2.aruco as aruco

import sys

# romipi specific marker dictionary and localization
from romipi_fiducials.board_poser import BoardPoser

VERBOSE = False 

class FiducialsNode():
    def __init__(self):
        ''' initialize subscriber from camera and publish image, fiducials '''

        rospy.init_node('romipi_fiducials_node', anonymous=True, log_level=rospy.INFO)

        self.image_publish = rospy.Publisher("/romipi_fiducials_node/fiducial_image/compressed", CompressedImage, queue_size=1)
        self.pose_publish = rospy.Publisher("/romipi_fiducials_node/observed_poses", RomiPose, queue_size=32)

        self.compressed_camera_image = None
        self.poser = BoardPoser()

    # FIXME may not be used
    @staticmethod
    def read_resolution(reader):
        node = reader.getNode("cameraResolution")
        return int(node.at(0).real()), int(node.at(1).real())
 
    @staticmethod
    def read_node_matrix(reader, name):
        node = reader.getNode(name)
        return node.mat()

    def camera_callback(self, ros_data):
        if VERBOSE:
            print 'received image of type: "%s"' % ros_data.format
        self.compressed_camera_image = ros_data

    def process_camera_image(self, frame):
        # got frame, now convert send to the tool for conversion to boards and poses
        self.poser.process_frame(frame) 
        board_pose_dict = self.poser.get_visible_board_poses()
        processed_frame = self.poser.get_frame()
        return processed_frame, board_pose_dict

    def ros_to_cv(self, cv_frame):
        """ ROS image to cv2 format """
        np_arr = np.fromstring(cv_frame.data, np.uint8)
        frame_header = cv_frame.header
        frame = cv2.imdecode(np_arr, cv2.IMREAD_COLOR)
        return frame, frame_header

    def cv_to_ros(self, cv_frame, header):
        """ converts an opencv format frame to ros format frame """
        ros_frame = CompressedImage()
        ros_frame.header = header
        ros_frame.format = "jpeg"
        ros_frame.data = np.array(cv2.imencode('.jpg', cv_frame)[1]).tostring()
        return ros_frame

    @staticmethod
    def pose_to_ros_pose(observer, target, pose, header):
        romi_pose = RomiPose()
        romi_pose.pose.header = header
        romi_pose.observer_name = observer
        romi_pose.target_name = target
        romi_pose.pose.pose.position.x = pose.getX(unit="m")
        romi_pose.pose.pose.position.y = pose.getY(unit="m")
        romi_pose.pose.pose.position.z = 0.0 # the passed in pose has no z axis
        qx, qy, qz, qw = pose.getQuaternion()
        romi_pose.pose.pose.orientation.x = qx 
        romi_pose.pose.pose.orientation.y = qy 
        romi_pose.pose.pose.orientation.z = qz 
        romi_pose.pose.pose.orientation.w = qw 
        return romi_pose

    def romipi_fiducials_node(self):
        # TODO convert this to a parameter
        camera_ros_path = "/raspicam_node/image/compressed"
        self.camera_subscriber = rospy.Subscriber(camera_ros_path, CompressedImage, self.camera_callback, queue_size = 1)
      
        rospy.loginfo("romipi fiducials node")

        rate = rospy.Rate(1) # rate is hz
        while not rospy.is_shutdown():
            # read image saved by the camera_callback
            if self.compressed_camera_image is not None:
                # ROS image to cv2 format
                frame, frame_header = self.ros_to_cv(self.compressed_camera_image)
                fiducial_frame_np, board_pose_dict = self.process_camera_image(frame)
                # convert processed frame to ROS format and publish
                self.image_publish.publish(self.cv_to_ros(fiducial_frame_np, frame_header))

                # TODO publish board dictionary
                # board_pose_dict
                for target in board_pose_dict:
                    observer = "jiffy_board" # TODO how do I find out own robot name?
                    target_pose = board_pose_dict[target]
                    ros_pose = self.pose_to_ros_pose(observer, target, target_pose, frame_header)
                    self.pose_publish.publish(ros_pose)
                    if VERBOSE:
                        print(ros_pose) 
            rate.sleep() 
        
if __name__ == '__main__':
    try:
        fiducials = FiducialsNode()
        fiducials.romipi_fiducials_node()
    except rospy.ROSInterruptException:
        pass

